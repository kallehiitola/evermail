---
description: Blazor component design and frontend patterns
globs: ["**/Pages/**/*.razor", "**/Components/**/*.razor", "**/*.razor"]
alwaysApply: false
---

# Blazor Frontend Patterns

## Admin Wizards & Automation

- üñ±Ô∏è **Point-and-click only.** Tenant/admin UX must never instruct users to copy JSON, run CLI commands, or leave the product. Buttons/wizards should call the secure endpoints directly.
- üß≠ **Guide inside the UI.** Use inline steps, tooltips, and status chips (hashes, timestamps) to confirm security actions like BYOK/SKR without exposing raw payloads.
- ‚ö†Ô∏è **No raw payload editors.** If a payload must be shown for transparency, keep it read-only and always provide a one-click ‚ÄúGenerate & Apply‚Äù action that performs the real work server-side.
- üîê **Recovery bundle exception.** When offering optional key backups (mnemonics, sealed blobs, JSON), keep them read-only, gate the download behind an ‚ÄúI understand Evermail can‚Äôt recover this‚Äù acknowledgement, and show a persistent warning to store it offline.

## Render Modes Standard (.NET 10)

**IMPORTANT**: All components in Evermail MUST follow these render mode guidelines to maintain consistency and avoid confusion.

### Official .NET 10 Render Modes

| Mode | Description | Location | Interactive | Use When |
|------|-------------|----------|-------------|----------|
| **Static Server** (default) | Static SSR, no interactivity | Server | ‚ùå No | Public pages, landing, marketing |
| **InteractiveServer** | Real-time via SignalR | Server | ‚úÖ Yes | Auth, email viewer, real-time updates |
| **InteractiveWebAssembly** | Client-side WASM | Client | ‚úÖ Yes | Offline capability, heavy client work |
| **InteractiveAuto** | Server first, then WASM | Server‚ÜíClient | ‚úÖ Yes | Best of both (downloads WASM in background) |

**Reference**: [ASP.NET Core Blazor render modes (.NET 10)](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-10.0)

### Evermail Standard: Per-Page/Component Approach

‚úÖ **DO**: Use **per-page/component** render modes (Microsoft's recommended default)

```razor
@page "/emails"
@rendermode InteractiveServer

<h1>My Emails</h1>
```

‚ùå **DON'T**: Use global interactivity (makes entire app interactive, poor performance)

```razor
@* BAD - Don't do this in App.razor *@
<Routes @rendermode="InteractiveServer" />
```

### Render Mode Decision Tree for Evermail

```
Does the page need interactivity? (@onclick, @bind, forms, etc.)
‚îú‚îÄ NO  ‚Üí Use default (Static Server)
‚îÇ       Examples: Landing page, About, Terms, Privacy
‚îÇ
‚îî‚îÄ YES ‚Üí Does it need real-time data or use auth?
    ‚îú‚îÄ YES ‚Üí Use @rendermode InteractiveServer
    ‚îÇ        Examples: Login, Register, Email Viewer, Search, Settings
    ‚îÇ
    ‚îî‚îÄ NO  ‚Üí Consider InteractiveWebAssembly or InteractiveAuto
             Examples: Email composer (offline draft), heavy data grids

For 90% of Evermail pages: Use InteractiveServer
```

### Standard Patterns by Page Type

#### 1. Authentication Pages (Login, Register, 2FA)
```razor
@page "/login"
@rendermode InteractiveServer
@using Evermail.Common.DTOs.Auth
@inject HttpClient Http
@inject NavigationManager Navigation

<EditForm Model="@_model" OnValidSubmit="@HandleLogin">
    @* Form content *@
</EditForm>

@code {
    // Interactivity needed for @onclick, @bind, form submission
}
```

**Why InteractiveServer?**
- ‚úÖ Access to HttpContext for cookies
- ‚úÖ Secure auth flow on server
- ‚úÖ Fast initial load (no WASM download)
- ‚úÖ Real-time validation

#### 2. Email Viewer/Search (Core App Features)
```razor
@page "/emails"
@rendermode InteractiveServer
@inject IEmailService EmailService

<MudTextField @bind-Value="_searchQuery" 
              @bind-Value:after="@SearchEmails"
              Label="Search" />

@foreach (var email in _emails)
{
    <EmailListItem Email="@email" @onclick="@(() => ViewEmail(email.Id))" />
}

@code {
    // Real-time search, filtering, navigation
}
```

**Why InteractiveServer?**
- ‚úÖ Real-time search as you type
- ‚úÖ Full .NET API access (EF Core queries)
- ‚úÖ Secure - code stays on server
- ‚úÖ Low latency for database operations

#### 3. Static Public Pages (Landing, About)
```razor
@page "/"
@* No @rendermode = Static Server (default) *@

<h1>Welcome to Evermail</h1>
<p>Transform your email archives into searchable knowledge.</p>

<a href="/register" class="btn btn-primary">Get Started</a>

@code {
    // No interactivity needed
    // Pure HTML, fast, SEO-friendly
}
```

**Why Static Server?**
- ‚úÖ Fastest initial load
- ‚úÖ SEO-friendly
- ‚úÖ No SignalR overhead
- ‚úÖ Can use forms with `method="post"`

#### 4. Admin Dashboard
```razor
@page "/admin/dashboard"
@rendermode InteractiveServer
@inject ITenantService TenantService

<AuthorizeView Roles="Admin,SuperAdmin">
    <Authorized>
        <MudDataGrid Items="@_tenants" 
                     @bind-SelectedItem="_selectedTenant">
            @* Real-time tenant management *@
        </MudDataGrid>
    </Authorized>
    <NotAuthorized>
        <CheckAuthAndRedirect />
    </NotAuthorized>
</AuthorizeView>

@code {
    // Real-time data updates, complex interactions
}
```

**Why InteractiveServer?**
- ‚úÖ Admin data stays on server (secure)
- ‚úÖ Real-time updates across admin actions
- ‚úÖ Full database access

#### 5. Future: Offline Email Composer (Phase 2+)
```razor
@page "/compose"
@rendermode InteractiveAuto
@* Must be in .Client project for WebAssembly *@

<MudTextField @bind-Value="_draftSubject" Label="Subject" />
<MudTextField @bind-Value="_draftBody" Lines="10" />

@code {
    // First visit: InteractiveServer (fast load)
    // Subsequent visits: InteractiveWebAssembly (offline drafts)
}
```

**Why InteractiveAuto?**
- ‚úÖ Best of both worlds
- ‚úÖ Fast first load
- ‚úÖ Offline capability after first visit
- ‚ö†Ô∏è Requires .Client project setup

### Render Mode Propagation Rules

**CRITICAL**: Render modes propagate down the component tree!

```razor
@* Parent: InteractiveServer *@
@page "/emails"
@rendermode InteractiveServer

<EmailList>                     @* ‚úÖ Inherits InteractiveServer *@
    <EmailListItem />           @* ‚úÖ Inherits InteractiveServer *@
</EmailList>

@* ‚ùå CANNOT switch from Server to WebAssembly in child *@
<WebAssemblyComponent />        @* ‚ùå ERROR! *@
```

**Rules**:
1. Default is Static (no render mode)
2. Can use different interactive modes for **sibling** components
3. **CANNOT** switch interactive render mode in child components
4. Parameters from Static‚ÜíInteractive must be JSON serializable (no RenderFragment)

### Authorization Pattern (Blazor)

**Do NOT use `@attribute [Authorize]` on Razor components.** It short-circuits the router and prevents redirects/404 pages.

Instead:

1. **Router-level guard** (`Components/Routes.razor`)
   - `<AuthorizeRouteView>` renders `<RedirectToLogin />` when unauthorized.
2. **Page-level guard**
   - Wrap every protected page in `<AuthorizeView>` with `<CheckAuthAndRedirect />` inside `<NotAuthorized>`.
   - Optionally set `Roles="..."` on `<AuthorizeView>` for role-specific pages.
3. **Shared components**
   - `<RedirectToLogin />` uses `Navigation.NavigateTo("/login?returnUrl=...")`.
   - `<CheckAuthAndRedirect />` verifies client-side auth after hydration and shows `<RequiresAuth />` fallback UI.

This pattern keeps HTTP responses 200 (so the Blazor app can render), ensures consistent redirects, and avoids `401` HTML pages for interactive routes.

### HttpClient Configuration by Render Mode

#### InteractiveServer (what we use)
```csharp
// Program.cs - Server project
builder.Services.AddScoped(sp =>
{
    var nav = sp.GetRequiredService<NavigationManager>();
    return new HttpClient { BaseAddress = new Uri(nav.BaseUri) };
});
```

#### InteractiveWebAssembly (future)
```csharp
// Program.cs - .Client project
builder.Services.AddScoped(sp => 
    new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
```

### When Static SSR Is Not Enough

Use `[ExcludeFromInteractiveRouting]` attribute for pages that **MUST** use Static SSR in an otherwise interactive app:

```razor
@page "/legacy/cookie-page"
@attribute [ExcludeFromInteractiveRouting]
@* Forces full page reload, exits interactive routing *@

@code {
    // Needed when page must read/write HTTP cookies directly
}
```

**Use cases for Evermail**:
- ‚ùå Probably never needed for Evermail
- Only for pages that REQUIRE request/response cycle (rare)

### Component Design Guidelines

‚úÖ **DO**: Design components to be render-mode agnostic when possible

```razor
@* Good - Works in any render mode *@
<MudText Typo="Typo.h1">@Title</MudText>

@code {
    [Parameter] public string Title { get; set; } = "";
    // No assumptions about where component runs
}
```

‚ùå **DON'T**: Couple component to specific render mode

```razor
@* Bad - Assumes browser environment *@
@code {
    protected override void OnInitialized()
    {
        // ‚ùå Won't work in Static SSR!
        var width = Window.InnerWidth;
    }
}
```

### Detecting Render Mode at Runtime (Advanced)

```razor
@if (!RendererInfo.IsInteractive)
{
    <p>Loading...</p>
}
else
{
    <button @onclick="HandleClick">Click me</button>
}

@code {
    // RendererInfo.Name: "Static", "Server", "WebAssembly", "WebView"
    // RendererInfo.IsInteractive: true/false
    // AssignedRenderMode: InteractiveServer, InteractiveAuto, etc.
}
```

### Prerendering (Enabled by Default)

All interactive modes prerender for fast initial load:

```
1. Server renders HTML (fast initial display)
2. Download .NET runtime (if WebAssembly)
3. Component becomes interactive
```

**To disable prerendering** (rarely needed):
```razor
@rendermode @(new InteractiveServerRenderMode(prerender: false))
```

### Migration Checklist

When adding a new page, ask:

- [ ] Does it need interactivity? (buttons, forms, @bind)
  - NO ‚Üí Use default (Static Server)
  - YES ‚Üí Continue
- [ ] Does it need auth, real-time data, or server APIs?
  - YES ‚Üí Use `@rendermode InteractiveServer` ‚úÖ (Evermail standard)
  - NO ‚Üí Consider InteractiveWebAssembly (future)
- [ ] Added `@inject` for HttpClient, NavigationManager, services?
- [ ] Tested: Does @onclick work? Do forms submit?
- [ ] Component placed in correct project?
  - InteractiveServer ‚Üí Any project ‚úÖ
  - InteractiveWebAssembly ‚Üí .Client project only

### Summary: Evermail Standard

**Default Choice**: `@rendermode InteractiveServer` for all interactive pages

**Reasoning**:
- ‚úÖ All app code stays on server (secure)
- ‚úÖ Full .NET API access (EF Core, Identity, etc.)
- ‚úÖ Fast initial load
- ‚úÖ Real-time updates via SignalR
- ‚úÖ No WASM download required
- ‚úÖ Perfect for SaaS with auth and database access

**When to deviate**: Only when you need offline capability (Phase 2+)

---

## Component Design

### Keep Components Small and Focused

```razor
@* Good ‚úÖ - Single responsibility *@
<EmailListItem Email="@Email" OnClick="@OnEmailClicked" />

@* Bad ‚ùå - Too many responsibilities *@
<EmailList>
    @* Contains search, filters, pagination, item rendering *@
</EmailList>
```

### Component Structure

```razor
@* EmailListItem.razor *@
@using Evermail.Common.DTOs

<MudPaper Class="mb-2 pa-4 cursor-pointer" @onclick="HandleClick">
    <div class="d-flex justify-space-between">
        <div class="flex-grow-1">
            <MudText Typo="Typo.subtitle1" Class="font-weight-bold">
                @Email.Subject
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                From: @Email.FromAddress | @Email.Date.ToString("MMM dd, yyyy")
            </MudText>
            <MudText Typo="Typo.body2" Class="mt-2">
                @Email.Snippet
            </MudText>
        </div>
        @if (Email.HasAttachments)
        {
            <MudIcon Icon="@Icons.Material.Filled.AttachFile" />
        }
    </div>
</MudPaper>

@code {
    [Parameter, EditorRequired]
    public EmailDto Email { get; set; } = null!;

    [Parameter]
    public EventCallback<Guid> OnClick { get; set; }

    private async Task HandleClick()
    {
        await OnClick.InvokeAsync(Email.Id);
    }
}
```

## Render Mode

```razor
@* For WebAssembly (interactive) *@
@rendermode InteractiveWebAssembly

@* For Server (real-time) *@
@rendermode InteractiveServer

@* For Admin Dashboard (Server) *@
@page "/admin/dashboard"
@rendermode InteractiveServer
@attribute [Authorize(Roles = "Admin")]
```

## State Management

### Service-Based State

```csharp
public class EmailSearchState
{
    private string _searchQuery = string.Empty;
    private List<EmailDto> _results = new();

    public string SearchQuery
    {
        get => _searchQuery;
        set
        {
            _searchQuery = value;
            OnStateChanged?.Invoke();
        }
    }

    public IReadOnlyList<EmailDto> Results => _results.AsReadOnly();

    public event Action? OnStateChanged;

    public void SetResults(List<EmailDto> results)
    {
        _results = results;
        OnStateChanged?.Invoke();
    }
}

// Register as scoped
builder.Services.AddScoped<EmailSearchState>();
```

### Component Usage

```razor
@inject EmailSearchState SearchState
@implements IDisposable

<MudTextField @bind-Value="SearchState.SearchQuery" 
              Label="Search emails"
              Immediate="true" />

<div class="mt-4">
    @foreach (var email in SearchState.Results)
    {
        <EmailListItem Email="@email" OnClick="@NavigateToEmail" />
    }
</div>

@code {
    protected override void OnInitialized()
    {
        SearchState.OnStateChanged += StateHasChanged;
    }

    public void Dispose()
    {
        SearchState.OnStateChanged -= StateHasChanged;
    }

    private void NavigateToEmail(Guid emailId)
    {
        NavigationManager.NavigateTo($"/emails/{emailId}");
    }
}
```

## HTTP Client Configuration

```csharp
// Program.cs
builder.Services.AddHttpClient("EverMailAPI", client =>
{
    client.BaseAddress = new Uri(builder.Configuration["ApiBaseUrl"]!);
})
.AddHttpMessageHandler<AuthenticationHandler>();

// AuthenticationHandler.cs
public class AuthenticationHandler : DelegatingHandler
{
    private readonly ILocalStorageService _localStorage;

    public AuthenticationHandler(ILocalStorageService localStorage)
    {
        _localStorage = localStorage;
    }

    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        var token = await _localStorage.GetItemAsync<string>("authToken");
        
        if (!string.IsNullOrEmpty(token))
        {
            request.Headers.Authorization = 
                new AuthenticationHeaderValue("Bearer", token);
        }

        return await base.SendAsync(request, cancellationToken);
    }
}
```

## API Service Pattern

```csharp
public interface IEmailService
{
    Task<ApiResponse<PagedResult<EmailDto>>> SearchAsync(
        string query,
        int page = 1,
        CancellationToken cancellationToken = default
    );
    Task<ApiResponse<EmailDto>> GetByIdAsync(Guid id);
}

public class EmailService : IEmailService
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly ILogger<EmailService> _logger;

    public EmailService(
        IHttpClientFactory httpClientFactory,
        ILogger<EmailService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _logger = logger;
    }

    public async Task<ApiResponse<PagedResult<EmailDto>>> SearchAsync(
        string query,
        int page = 1,
        CancellationToken cancellationToken = default)
    {
        var client = _httpClientFactory.CreateClient("EverMailAPI");
        
        try
        {
            var response = await client.GetFromJsonAsync<ApiResponse<PagedResult<EmailDto>>>(
                $"/api/v1/emails/search?q={Uri.EscapeDataString(query)}&page={page}",
                cancellationToken
            );

            return response ?? new ApiResponse<PagedResult<EmailDto>>(
                Success: false,
                Error: "No response from server"
            );
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP error searching emails");
            return new ApiResponse<PagedResult<EmailDto>>(
                Success: false,
                Error: "Network error. Please try again."
            );
        }
    }
}
```

## MudBlazor Usage

```razor
@using MudBlazor

@* Dialog *@
<MudDialog>
    <DialogContent>
        <MudText>Are you sure you want to delete this mailbox?</MudText>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Error" Variant="Variant.Filled" OnClick="Confirm">
            Delete
        </MudButton>
    </DialogActions>
</MudDialog>

@* Loading State *@
@if (_isLoading)
{
    <MudProgressCircular Indeterminate="true" />
}
else if (_emails?.Any() == true)
{
    @foreach (var email in _emails)
    {
        <EmailListItem Email="@email" />
    }
}
else
{
    <MudText Typo="Typo.body1" Color="Color.Secondary">
        No emails found
    </MudText>
}

@* Snackbar for notifications *@
@inject ISnackbar Snackbar

@code {
    private async Task DeleteMailbox()
    {
        var result = await MailboxService.DeleteAsync(mailboxId);
        
        if (result.Success)
        {
            Snackbar.Add("Mailbox deleted successfully", Severity.Success);
        }
        else
        {
            Snackbar.Add(result.Error ?? "Failed to delete mailbox", Severity.Error);
        }
    }
}
```

## Form Handling

```razor
<EditForm Model="@_model" OnValidSubmit="@HandleSubmit">
    <DataAnnotationsValidator />
    
    <MudTextField Label="Email"
                  @bind-Value="_model.Email"
                  For="@(() => _model.Email)"
                  Required="true" />
    
    <MudTextField Label="Password"
                  @bind-Value="_model.Password"
                  For="@(() => _model.Password)"
                  InputType="InputType.Password"
                  Required="true" />
    
    <MudButton ButtonType="ButtonType.Submit"
               Variant="Variant.Filled"
               Color="Color.Primary"
               Disabled="@_isSubmitting">
        @if (_isSubmitting)
        {
            <MudProgressCircular Size="Size.Small" Indeterminate="true" />
            <MudText Class="ml-2">Logging in...</MudText>
        }
        else
        {
            <MudText>Login</MudText>
        }
    </MudButton>
</EditForm>

@code {
    private LoginModel _model = new();
    private bool _isSubmitting;

    private async Task HandleSubmit()
    {
        _isSubmitting = true;
        
        try
        {
            var result = await AuthService.LoginAsync(_model);
            
            if (result.Success)
            {
                await LocalStorage.SetItemAsync("authToken", result.Data!.Token);
                NavigationManager.NavigateTo("/");
            }
            else
            {
                Snackbar.Add(result.Error ?? "Login failed", Severity.Error);
            }
        }
        finally
        {
            _isSubmitting = false;
        }
    }

    public class LoginModel
    {
        [Required, EmailAddress]
        public string Email { get; set; } = string.Empty;

        [Required, MinLength(12)]
        public string Password { get; set; } = string.Empty;
    }
}
```

## Error Boundaries

```razor
<ErrorBoundary>
    <ChildContent>
        @* Your components here *@
        <EmailList />
    </ChildContent>
    <ErrorContent Context="exception">
        <MudAlert Severity="Severity.Error">
            <MudText Typo="Typo.h6">An error occurred</MudText>
            <MudText Typo="Typo.body2">@exception.Message</MudText>
        </MudAlert>
    </ErrorContent>
</ErrorBoundary>
```

## Performance Optimization

### Virtualization for Large Lists

```razor
<Virtualize Items="@_emails" Context="email">
    <EmailListItem Email="@email" />
</Virtualize>
```

### ShouldRender Override

```csharp
@code {
    private string _lastSearchQuery = string.Empty;

    protected override bool ShouldRender()
    {
        // Only re-render if search query changed
        if (_lastSearchQuery != SearchQuery)
        {
            _lastSearchQuery = SearchQuery;
            return true;
        }
        return false;
    }
}
```
