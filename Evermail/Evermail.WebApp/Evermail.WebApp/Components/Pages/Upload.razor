@page "/upload"
@rendermode InteractiveServer
@using Evermail.Common.Constants
@using Evermail.Common.DTOs
@using Evermail.Common.DTOs.Upload
@using Evermail.Common.DTOs.Tenant
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.WebUtilities
@using Evermail.WebApp.Services
@using System.Net.Http.Json
@using System.Net.Http.Headers
@using System.IO
@using System.Collections.Generic
@using System.Linq
@using Microsoft.JSInterop
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject IAuthenticationStateService AuthStateService

<PageTitle>Upload Email Archive - Evermail</PageTitle>

<AuthorizeView>
    <Authorized>
<div class="home-wrapper upload-wrapper">
    <section class="page-hero upload-hero">
        <div>
            <p class="hero-eyebrow mb-2">@(_targetMailboxId.HasValue ? "Re-import" : "New ingestion")</p>
            <h1>@UploadTitle</h1>
            <p class="text-muted mb-0">@UploadSubtitle</p>
        </div>
        <div class="upload-hero-stats">
            <div>
                <span>@_maxFileSizeGB GB</span>
                <small>Per file limit</small>
            </div>
            <div>
                <span>Resume-ready</span>
                <small>Large files, pick up where you left off</small>
            </div>
            <div>
                <span>ZIP · PST · OST · EML</span>
                <small>Auto-normalized formats</small>
            </div>
        </div>
    </section>
    
    @if (_isUploading)
    {
        <section class="modern-card upload-progress-card">
            <p class="hero-eyebrow mb-1">Transferring @_fileName</p>
            <h2>Upload in progress</h2>
            <div class="usage-progress jumbo" role="progressbar" aria-valuenow="@_uploadProgress" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width:@_uploadProgress%"></div>
            </div>
            <p class="text-muted mb-1">
                @_uploadedMB.ToString("F2") MB / @_totalMB.ToString("F2") MB · @_uploadSpeedMBps.ToString("F2") MB/s
                @if (_estimatedTimeRemaining > TimeSpan.Zero)
                {
                    <span> · ETA @_estimatedTimeRemaining.ToString(@"mm\:ss")</span>
                }
            </p>
            <button class="btn btn-outline-danger" @onclick="CancelUpload">
                <i class="bi bi-x-circle me-2"></i>Cancel upload
            </button>
        </section>
    }
    else if (_uploadComplete)
    {
        <section class="modern-card success-card text-center py-5">
            <i class="bi bi-check-circle display-5 text-success"></i>
            <h2 class="mt-3">Upload complete</h2>
            <p class="text-muted">Your archive is queued for processing. We'll notify you once ingestion finishes.</p>
            <a href="/mailboxes/@_completedMailboxId" class="btn btn-primary">
                <i class="bi bi-inbox me-2"></i>View mailbox status
            </a>
        </section>
    }
    else
    {
        @if (!string.IsNullOrEmpty(_errorMessage))
        {
            <div class="alert alert-danger modern-alert">@_errorMessage</div>
        }

        <section class="modern-card upload-card">
            <div class="upload-grid">
                <div>
                    <label class="form-label fw-semibold">Upload source</label>
                    <div class="@DropzoneCssClass"
                         @ondragenter="() => _isDragOver = true"
                         @ondragleave="() => _isDragOver = false">
                        <InputFile OnChange="HandleFileSelected"
                                   class="upload-dropzone__input"
                                   accept=".mbox,.mbx,.zip,.pst,.ost,.eml"
                                   id="fileInput"
                                   @ondragenter="() => _isDragOver = true"
                                   @ondragleave="() => _isDragOver = false"
                                   @ondragover:preventDefault="true"
                                   @ondrop="HandleDrop" />
                        <div class="upload-dropzone__content">
                            @if (_selectedFile is null)
                            {
                                <i class="bi bi-cloud-arrow-up display-5 text-muted"></i>
                                <p class="lead mb-1">Drag & drop .mbox, .pst, .ost, .eml, or .zip</p>
                                <p class="text-muted small mb-0">or click to browse files</p>
                                <span class="text-muted extra-small">Files encrypt directly to Azure Blob Storage</span>
                            }
                            else
                            {
                                <div class="upload-filechip">
                                    <div>
                                        <strong>@_fileName</strong>
                                        <span>@_totalMB.ToString("F2") MB</span>
                                    </div>
                                    <button type="button" class="upload-filechip__remove" @onclick="ClearSelection">
                                        <i class="bi bi-x-lg"></i>
                                    </button>
                                </div>
                                <p class="text-muted small mb-0">Ready to upload.</p>
                            }
                        </div>
                    </div>
                    <p class="text-muted small mt-2">Supports .mbox/.mbx, Outlook PST/OST (raw or zipped), Google Takeout, and Maildir-style `.eml` bundles — we detect the format automatically.</p>
                </div>
                <div class="upload-meta">
                    <label class="form-label fw-semibold">Format detection</label>
                    <div class="modern-card subtle-card mb-3">
                        <p class="mb-1 fw-semibold">@FormatDetectionSummary</p>
                        <p class="text-muted small mb-0">@FormatDetectionDetails</p>
                    </div>
                    <div class="upload-plan-card">
                        <p class="text-muted mb-1">Plan limit</p>
                        <h4 class="mb-0">@_maxFileSizeGB GB per file</h4>
                        <small>Need more? Upgrade under Settings → Subscription.</small>
                    </div>
                    <button class="btn btn-primary btn-xl w-100 auth-primary-button mt-2"
                            @onclick="StartUpload"
                            disabled="@(_selectedFile == null || _isProcessing)">
                        @(_targetMailboxId.HasValue ? "Merge upload" : "Start upload")
                    </button>
                </div>
            </div>
        </section>

        @if (_supportsZeroAccess)
        {
            <section class="modern-card zero-access-card">
                <div class="d-flex align-items-center justify-content-between flex-wrap gap-3">
                    <div>
                        <p class="hero-eyebrow mb-1 text-uppercase">Zero-access mode</p>
                        <h4 class="mb-1">Encrypt in the browser so Evermail never sees plaintext.</h4>
                        <p class="text-muted mb-0">
                            Available because your tenant is configured for BYOK. We'll block server-side ingestion and store the ciphertext exactly as you upload it.
                        </p>
                    </div>
                    <div class="form-check form-switch zero-access-toggle">
                        <input class="form-check-input"
                               type="checkbox"
                               role="switch"
                               id="zeroAccessToggle"
                               checked="@_useZeroAccess"
                               @onchange="OnZeroAccessToggleChanged" />
                        <label class="form-check-label" for="zeroAccessToggle">
                            Client-side encryption
                        </label>
                    </div>
                </div>

                @if (_useZeroAccess)
                {
                    <div class="alert alert-warning mt-3" role="alert">
                        <i class="bi bi-shield-lock me-2"></i>
                        Store this key offline—Evermail cannot recover it for you.
                    </div>

                    @if (_zeroAccessBundle is not null)
                    {
                        <div class="zero-access-keybundle mt-3">
                            <div class="zero-access-keybundle__header">
                                <div>
                                    <p class="mb-1 fw-semibold">Encryption key</p>
                                    <code class="zero-access-keybundle__value">@_zeroAccessBundle.KeyBase64</code>
                                </div>
                                <div class="zero-access-keybundle__actions">
                                    <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="CopyZeroAccessKeyAsync">
                                        <i class="bi bi-clipboard me-1"></i>Copy
                                    </button>
                                    <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="DownloadZeroAccessBundleAsync">
                                        <i class="bi bi-download me-1"></i>Download bundle
                                    </button>
                                    <button class="btn btn-link btn-sm text-decoration-none" type="button" @onclick="GenerateZeroAccessKeyAsync">
                                        Regenerate
                                    </button>
                                </div>
                            </div>
                            <div class="zero-access-keybundle__meta">
                                <div>
                                    <span class="label">Fingerprint</span>
                                    <span class="value">@_zeroAccessBundle.Fingerprint</span>
                                </div>
                                <div>
                                    <span class="label">Scheme</span>
                                    <span class="value">@_zeroAccessBundle.Scheme</span>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <p class="text-muted small mt-3">Generating encryption key...</p>
                    }

                    <div class="mt-4">
                        <label class="form-label fw-semibold">Mailbox tags (optional)</label>
                        <textarea class="form-control"
                                  rows="2"
                                  placeholder="Comma-separated tags, e.g. case-4821,project-omega"
                                  @bind="_zeroAccessTagInput"></textarea>
                        <small class="text-muted">
                            We hash these tags in your browser so you can filter encrypted mailboxes later. Never send plaintext labels to Evermail.
                        </small>
                    </div>

                    <div class="mt-4">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <label class="form-label fw-semibold mb-0">Header indexing</label>
                            <button class="btn btn-outline-secondary btn-sm"
                                    type="button"
                                    disabled="@(_selectedFile is null || _isHeaderScanRunning)"
                                    @onclick="RescanHeadersAsync">
                                <i class="bi bi-arrow-clockwise me-1"></i>Rescan
                            </button>
                        </div>

                        @switch (_headerIndexStatus.State)
                        {
                            case HeaderIndexState.Hidden:
                                <p class="text-muted small mb-0">
                                    Header indexing runs for .mbox/.mbx uploads when client-side encryption is enabled.
                                </p>
                                break;
                            case HeaderIndexState.Running:
                                <p class="text-muted small mb-0">
                                    <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                                    Scanning message headers…
                                </p>
                                break;
                            case HeaderIndexState.Completed:
                                <div class="zero-access-header-summary mt-2">
                                    <p class="text-muted small mb-1">
                                        @_headerIndexStatus.ScannedMessages message@(_headerIndexStatus.ScannedMessages == 1 ? string.Empty : "s") sampled.
                                    </p>
                                    <ul class="list-unstyled small mb-0">
                                        <li>
                                            <strong>From</strong>: @GetHeaderTokenCount("from")
                                            @if (IsHeaderTokenCapped("from"))
                                            {
                                                <span class="badge bg-warning-subtle text-warning-emphasis ms-1">capped</span>
                                            }
                                        </li>
                                        <li>
                                            <strong>To</strong>: @GetHeaderTokenCount("to")
                                            @if (IsHeaderTokenCapped("to"))
                                            {
                                                <span class="badge bg-warning-subtle text-warning-emphasis ms-1">capped</span>
                                            }
                                        </li>
                                        <li>
                                            <strong>Cc</strong>: @GetHeaderTokenCount("cc")
                                            @if (IsHeaderTokenCapped("cc"))
                                            {
                                                <span class="badge bg-warning-subtle text-warning-emphasis ms-1">capped</span>
                                            }
                                        </li>
                                        <li>
                                            <strong>Subjects</strong>: @GetHeaderTokenCount("subject")
                                            @if (IsHeaderTokenCapped("subject"))
                                            {
                                                <span class="badge bg-warning-subtle text-warning-emphasis ms-1">capped</span>
                                            }
                                        </li>
                                    </ul>
                                </div>
                                break;
                            case HeaderIndexState.Skipped:
                                <div class="alert alert-warning mt-2 mb-0" role="alert">
                                    @_headerIndexStatus.Message
                                </div>
                                break;
                            case HeaderIndexState.Error:
                                <div class="alert alert-danger mt-2 mb-0" role="alert">
                                    @_headerIndexStatus.Message
                                </div>
                                break;
                        }
                    </div>
                }
            </section>
        }

        @if (_targetMailboxId.HasValue)
        {
            <section class="modern-card subtle-card">
                <p class="hero-eyebrow mb-1">Re-import active</p>
                <p class="mb-0">New messages merge into mailbox <span class="mono">@_targetMailboxId</span>. Duplicates are skipped automatically.</p>
            </section>
        }
    }
</div>
    </Authorized>
    <NotAuthorized>
        <CheckAuthAndRedirect />
    </NotAuthorized>
</AuthorizeView>

@code {
    private IBrowserFile? _selectedFile;
    private string _fileName = string.Empty;
    private string? _formatHint;
    private long _totalBytes;
    private double _totalMB;
    private double _totalGB;
    private int _maxFileSizeGB = 100;
    
    private bool _isUploading;
    private bool _isProcessing;
    private bool _uploadComplete;
    private int _uploadProgress;
    private long _uploadedBytes;
    private double _uploadedMB;
    private double _uploadSpeedMBps;
    private TimeSpan _estimatedTimeRemaining;
    private string _errorMessage = string.Empty;
    private Guid _completedMailboxId;
    private Guid? _targetMailboxId;
    private bool _isDragOver;
    private bool _hasClientSideError;
    private TenantOnboardingStatusDto? _tenantStatus;
    private bool _supportsZeroAccess;
    private bool _useZeroAccess;
    private ZeroAccessKeyBundleModel? _zeroAccessBundle;
    private string _zeroAccessTagInput = string.Empty;
    private ZeroAccessHeaderIndexStatus _headerIndexStatus = ZeroAccessHeaderIndexStatus.Hidden();
    private Dictionary<string, string[]>? _headerPreviewValues;
    private Dictionary<string, IReadOnlyList<string>>? _headerHashedTokens;
    private bool _isHeaderScanRunning;

    private string DropzoneCssClass => _selectedFile is null
        ? _isDragOver ? "upload-dropzone upload-dropzone--drag" : "upload-dropzone"
        : "upload-dropzone upload-dropzone--selected";

    private string FormatDetectionSummary => string.IsNullOrWhiteSpace(_formatHint)
        ? "We'll auto-detect your archive"
        : $"Detected {FormatDisplayName(_formatHint)}";

    private string FormatDetectionDetails => string.IsNullOrWhiteSpace(_formatHint)
        ? "Upload ZIP, PST, OST, MBOX, or EML files — we'll inspect the contents and pick the right pipeline."
        : "Based on the current file name. We'll still verify the contents before processing.";

    private string UploadTitle => _targetMailboxId.HasValue ? "Refresh mailbox data" : "Upload email archive";
    private string UploadSubtitle => _targetMailboxId.HasValue
        ? "Merge a newer export without creating duplicates."
        : "Drag & drop .mbox, .pst, .eml, or Takeout exports to start ingestion.";

    protected override async Task OnInitializedAsync()
    {
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var query = QueryHelpers.ParseQuery(uri.Query);
        if (query.TryGetValue("mailboxId", out var mailboxIdParam) && Guid.TryParse(mailboxIdParam, out var mailboxId))
        {
            _targetMailboxId = mailboxId;
        }

        // TODO: Fetch actual tenant plan limit from API
        _maxFileSizeGB = 100;

        await LoadTenantStatusAsync();
    }

    private async Task LoadTenantStatusAsync()
    {
        try
        {
            var token = await AuthStateService.GetTokenAsync();
            if (string.IsNullOrWhiteSpace(token))
            {
                _supportsZeroAccess = false;
                _useZeroAccess = false;
                return;
            }

            var request = new HttpRequestMessage(
                HttpMethod.Get,
                $"{Navigation.BaseUri}api/v1/tenants/onboarding/status");
            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);

            var response = await Http.SendAsync(request);
            if (!response.IsSuccessStatusCode)
            {
                _supportsZeroAccess = false;
                _useZeroAccess = false;
                return;
            }

            var statusResponse =
                await response.Content.ReadFromJsonAsync<ApiResponse<TenantOnboardingStatusDto>>();
            if (statusResponse?.Success == true && statusResponse.Data is not null)
            {
                _tenantStatus = statusResponse.Data;
                _supportsZeroAccess = statusResponse.Data.EncryptionConfigured &&
                    string.Equals(statusResponse.Data.SecurityPreference, "BYOK", StringComparison.OrdinalIgnoreCase);
                if (!_supportsZeroAccess)
                {
                    _useZeroAccess = false;
                }
            }
        }
        catch
        {
            _supportsZeroAccess = false;
            _useZeroAccess = false;
        }
    }

    private async Task OnZeroAccessToggleChanged(ChangeEventArgs args)
    {
        if (!_supportsZeroAccess)
        {
            _useZeroAccess = false;
            return;
        }

        var next = args.Value switch
        {
            bool b => b,
            string s when bool.TryParse(s, out var parsed) => parsed,
            _ => !_useZeroAccess
        };

        _useZeroAccess = _supportsZeroAccess && next;

        if (_useZeroAccess)
        {
            await EnsureZeroAccessBundleAsync();
            await ScanZeroAccessHeadersAsync();
        }
        else
        {
            ResetZeroAccessHeaderState();
        }
    }

    private async Task EnsureZeroAccessBundleAsync(bool force = false)
    {
        if (!_useZeroAccess)
        {
            _zeroAccessBundle = null;
            return;
        }

        if (!force && _zeroAccessBundle is not null)
        {
            return;
        }

        try
        {
            _zeroAccessBundle = await JS.InvokeAsync<ZeroAccessKeyBundleModel>("zeroAccessUpload.generateBundle");
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to generate encryption key: {ex.Message}";
            _useZeroAccess = false;
        }
    }

    private Task GenerateZeroAccessKeyAsync() => EnsureZeroAccessBundleAsync(force: true);

    private async Task CopyZeroAccessKeyAsync()
    {
        if (_zeroAccessBundle is null)
        {
            return;
        }

        await JS.InvokeVoidAsync("zeroAccessUpload.copyToClipboard", _zeroAccessBundle.KeyBase64);
    }

    private async Task DownloadZeroAccessBundleAsync()
    {
        if (_zeroAccessBundle is null)
        {
            return;
        }

        var bundle = new
        {
            key = _zeroAccessBundle.KeyBase64,
            fingerprint = _zeroAccessBundle.Fingerprint,
            noncePrefix = _zeroAccessBundle.NoncePrefixBase64,
            scheme = _zeroAccessBundle.Scheme,
            generatedAt = DateTime.UtcNow
        };

        await JS.InvokeVoidAsync("zeroAccessUpload.downloadBundle", bundle);
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File != null)
        {
            ApplySelectedFile(e.File);
            _isDragOver = false;
            if (_useZeroAccess)
            {
            await ScanZeroAccessHeadersAsync();
            }
        }
    }

    private void ApplySelectedFile(IBrowserFile file)
    {
        _selectedFile = file;
        _fileName = file.Name;
        _totalBytes = file.Size;
        _totalMB = _totalBytes / (1024.0 * 1024.0);
        _totalGB = _totalBytes / (1024.0 * 1024.0 * 1024.0);
        _errorMessage = string.Empty;
        _uploadComplete = false;
        _uploadProgress = 0;
        _formatHint = GuessFormatFromExtension(Path.GetExtension(_fileName)?.ToLowerInvariant());
        ResetZeroAccessHeaderState();
    }

    private void ClearSelection()
    {
        _selectedFile = null;
        _fileName = string.Empty;
        _totalBytes = 0;
        _totalMB = 0;
        _totalGB = 0;
        _isDragOver = false;
        _formatHint = null;
        ResetZeroAccessHeaderState();
    }

    private void HandleDrop(DragEventArgs _)
    {
        _isDragOver = false;
        StateHasChanged();
    }

    private async Task StartUpload()
    {
        if (_selectedFile == null)
        {
            return;
        }

        if (_totalGB > _maxFileSizeGB)
        {
            _errorMessage = $"File size ({_totalGB:F2} GB) exceeds your plan limit ({_maxFileSizeGB} GB). Please upgrade your subscription.";
            return;
        }

        _isProcessing = true;
        _errorMessage = string.Empty;

        try
        {
            var token = await AuthStateService.GetTokenAsync();
            if (string.IsNullOrEmpty(token))
            {
                _errorMessage = "You must be logged in to upload files";
                return;
            }

            string sasUrl;
            Guid mailboxId;
            Guid uploadId;
            string? tokenSalt = null;

            if (_useZeroAccess)
            {
                var zeroAccessRequest = new HttpRequestMessage(
                    HttpMethod.Post,
                    $"{Navigation.BaseUri}api/v1/mailboxes/encrypted-upload/initiate");
                zeroAccessRequest.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
                zeroAccessRequest.Content = JsonContent.Create(new InitiateZeroAccessUploadRequest(
                    _fileName,
                    _totalBytes,
                    _targetMailboxId,
                    "zero-access/aes-gcm-chunked/v1"));

                var zeroAccessResponse = await Http.SendAsync(zeroAccessRequest);
                if (!zeroAccessResponse.IsSuccessStatusCode)
                {
                    var error = await zeroAccessResponse.Content.ReadAsStringAsync();
                    _errorMessage = $"Failed to initiate encrypted upload: {error}";
                    return;
                }

                var payload = await zeroAccessResponse.Content
                    .ReadFromJsonAsync<ApiResponse<InitiateZeroAccessUploadResponse>>();

                if (payload?.Success != true || payload.Data is null)
                {
                    _errorMessage = payload?.Error ?? "Failed to initiate encrypted upload";
                    return;
                }

                sasUrl = payload.Data.UploadUrl;
                mailboxId = payload.Data.MailboxId;
                uploadId = payload.Data.UploadId;
                tokenSalt = payload.Data.TokenSalt;
            }
            else
            {
                var apiUrl = $"{Navigation.BaseUri}api/v1/upload/initiate";
                var request = new HttpRequestMessage(HttpMethod.Post, apiUrl);
                request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
                request.Content = JsonContent.Create(new InitiateUploadRequest(
                    _fileName,
                    _totalBytes,
                    _formatHint,
                    _targetMailboxId,
                    ClientSideEncryption: false));

                var initiateResponse = await Http.SendAsync(request);
                if (!initiateResponse.IsSuccessStatusCode)
                {
                    var errorContent = await initiateResponse.Content.ReadAsStringAsync();
                    _errorMessage = $"Failed to initiate upload: {errorContent}";
                    return;
                }

                var result = await initiateResponse.Content.ReadFromJsonAsync<ApiResponse<InitiateUploadResponse>>();
                if (result?.Success != true || result.Data is null)
                {
                    _errorMessage = result?.Error ?? "Failed to initiate upload";
                    return;
                }

                sasUrl = result.Data.UploadUrl;
                mailboxId = result.Data.MailboxId;
                uploadId = result.Data.UploadId;
            }

            _isProcessing = false;
            _isUploading = true;

            var uploadMetadata = await UploadToAzureBlobAsync(sasUrl);
            if (!_isUploading)
            {
                return;
            }

            if (_useZeroAccess)
            {
                if (uploadMetadata is null || _zeroAccessBundle is null || string.IsNullOrWhiteSpace(tokenSalt))
                {
                    _errorMessage = "Encrypted upload failed to return metadata.";
                    _isUploading = false;
                    return;
                }

                var tokenSets = await BuildDeterministicTokenSetsAsync(tokenSalt);

                var zeroAccessUrl = $"{Navigation.BaseUri}api/v1/mailboxes/encrypted-upload/complete";
                var zeroAccessRequest = new HttpRequestMessage(HttpMethod.Post, zeroAccessUrl);
                zeroAccessRequest.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
                zeroAccessRequest.Content = JsonContent.Create(new CompleteZeroAccessUploadRequest(
                    mailboxId,
                    uploadId,
                    _zeroAccessBundle.Scheme,
                    _zeroAccessBundle.Fingerprint,
                    uploadMetadata.MetadataJson,
                    _totalBytes,
                    uploadMetadata.CipherSizeBytes,
                    tokenSets
                ));

                var zeroAccessResponse = await Http.SendAsync(zeroAccessRequest);
                if (!zeroAccessResponse.IsSuccessStatusCode)
                {
                    _errorMessage = "Encrypted upload completed but failed to finalize.";
                    return;
                }
            }
            else
            {
                var completeUrl = $"{Navigation.BaseUri}api/v1/upload/complete";
                var completeRequest = new HttpRequestMessage(HttpMethod.Post, completeUrl);
                completeRequest.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
                completeRequest.Content = JsonContent.Create(new CompleteUploadRequest(
                    mailboxId,
                    uploadId));

                var completeResponse = await Http.SendAsync(completeRequest);

                if (!completeResponse.IsSuccessStatusCode)
                {
                    _errorMessage = "Upload completed but failed to queue for processing";
                    return;
                }
            }

            _isUploading = false;
            _uploadComplete = true;
            _completedMailboxId = mailboxId;
        }
        catch (Exception ex)
        {
            if (string.IsNullOrWhiteSpace(_errorMessage))
            {
                _errorMessage = $"Error: {ex.Message}";
            }
            _isUploading = false;
        }
        finally
        {
            _isProcessing = false;
        }
    }

    private async Task<ZeroAccessUploadResultModel?> UploadToAzureBlobAsync(string sasUrl)
    {
        DotNetObjectReference<Upload>? dotNetRef = null;
        try
        {
            dotNetRef = DotNetObjectReference.Create(this);
            if (_useZeroAccess)
            {
                if (_zeroAccessBundle is null)
                {
                    throw new InvalidOperationException("Encryption key bundle is missing.");
                }

                var options = new
                {
                    keyBase64 = _zeroAccessBundle.KeyBase64,
                    fingerprint = _zeroAccessBundle.Fingerprint,
                    noncePrefixBase64 = _zeroAccessBundle.NoncePrefixBase64,
                    scheme = _zeroAccessBundle.Scheme,
                    chunkSize = 4 * 1024 * 1024
                };

                var result = await JS.InvokeAsync<ZeroAccessUploadResultModel>(
                    "zeroAccessUpload.encryptAndUpload",
                    sasUrl,
                    dotNetRef,
                    options);

                return result;
            }
            else
            {
                await JS.InvokeVoidAsync("azureBlobUpload.upload", sasUrl, dotNetRef);
                return null;
            }
        }
        catch (Exception ex)
        {
            if (!_hasClientSideError)
            {
                _errorMessage = $"Upload failed: {ex.Message}";
            }
            _isUploading = false;
            return null;
        }
        finally
        {
            dotNetRef?.Dispose();
            _hasClientSideError = false;
        }
    }

    [JSInvokable]
    public void UpdateProgress(int progress, long uploadedBytes, double speedMBps)
    {
        _uploadProgress = progress;
        _uploadedBytes = uploadedBytes;
        _uploadedMB = uploadedBytes / (1024.0 * 1024.0);
        _uploadSpeedMBps = speedMBps;
        
        if (speedMBps > 0)
        {
            var remainingBytes = _totalBytes - uploadedBytes;
            var remainingSeconds = remainingBytes / (speedMBps * 1024 * 1024);
            _estimatedTimeRemaining = TimeSpan.FromSeconds(remainingSeconds);
        }
        
        StateHasChanged();
    }

    private void CancelUpload()
    {
        _isUploading = false;
        _errorMessage = "Upload cancelled";
    }

    private string? GuessFormatFromExtension(string? extension) => extension switch
    {
        ".pst" => EmailArchiveFormats.OutlookPst,
        ".ost" => EmailArchiveFormats.OutlookOst,
        ".mbox" => EmailArchiveFormats.Mbox,
        ".mbx" => EmailArchiveFormats.Mbox,
        ".eml" => EmailArchiveFormats.Eml,
        _ => null
    };

    private static string FormatDisplayName(string format) => format switch
    {
        EmailArchiveFormats.OutlookPst => "Outlook PST",
        EmailArchiveFormats.OutlookOst => "Outlook OST",
        EmailArchiveFormats.OutlookPstZip => "Outlook PST ZIP",
        EmailArchiveFormats.OutlookOstZip => "Outlook OST ZIP",
        EmailArchiveFormats.MicrosoftExportZip => "Outlook export ZIP",
        EmailArchiveFormats.GoogleTakeoutZip => "Google Takeout ZIP",
        EmailArchiveFormats.Eml => "single EML",
        EmailArchiveFormats.EmlZip => "EML ZIP bundle",
        EmailArchiveFormats.Mbox => ".mbox archive",
        _ => format
    };

    private IReadOnlyList<string> ParseZeroAccessTags()
    {
        if (string.IsNullOrWhiteSpace(_zeroAccessTagInput))
        {
            return Array.Empty<string>();
        }

        return _zeroAccessTagInput
            .Split(new[] { ',', ';', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(tag => tag.Trim())
            .Where(tag => !string.IsNullOrWhiteSpace(tag))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToArray();
    }

    private async Task<IReadOnlyList<string>> BuildZeroAccessTagTokensAsync(string tokenSaltBase64)
    {
        if (_zeroAccessBundle is null)
        {
            return Array.Empty<string>();
        }

        var tags = ParseZeroAccessTags();
        if (tags.Count == 0)
        {
            return Array.Empty<string>();
        }

        try
        {
            var tokens = await JS.InvokeAsync<string[]>(
                "zeroAccessUpload.deriveTagTokens",
                _zeroAccessBundle,
                tokenSaltBase64,
                tags.ToArray());

            return tokens ?? Array.Empty<string>();
        }
        catch
        {
            return Array.Empty<string>();
        }
    }

    private async Task<Dictionary<string, IReadOnlyList<string>>?> BuildZeroAccessHeaderTokensAsync(string tokenSaltBase64)
    {
        if (_zeroAccessBundle is null)
        {
            return null;
        }

        if (_headerPreviewValues is null || _headerPreviewValues.Count == 0)
        {
            await ScanZeroAccessHeadersAsync();
        }

        if (_headerPreviewValues is null || _headerPreviewValues.Count == 0)
        {
            return null;
        }

        try
        {
            var hashed = await JS.InvokeAsync<Dictionary<string, string[]>>(
                "zeroAccessUpload.hashHeaderTokens",
                _zeroAccessBundle,
                tokenSaltBase64,
                _headerPreviewValues);

            if (hashed is null || hashed.Count == 0)
            {
                return null;
            }

            var result = hashed.ToDictionary(
                kvp => kvp.Key,
                kvp => (IReadOnlyList<string>)kvp.Value,
                StringComparer.OrdinalIgnoreCase);
            _headerHashedTokens = result;
            return result;
        }
        catch (JSException jsEx)
        {
            _headerIndexStatus = ZeroAccessHeaderIndexStatus.Error($"Failed to hash header tokens: {jsEx.Message}");
            return null;
        }
    }

    private async Task<IReadOnlyList<DeterministicTokenSetDto>?> BuildDeterministicTokenSetsAsync(string tokenSaltBase64)
    {
        var deterministicSets = new List<DeterministicTokenSetDto>();

        var tagTokens = await BuildZeroAccessTagTokensAsync(tokenSaltBase64);
        if (tagTokens.Count > 0)
        {
            deterministicSets.Add(new DeterministicTokenSetDto("tag", tagTokens));
        }

        var headerTokens = await BuildZeroAccessHeaderTokensAsync(tokenSaltBase64);
        if (headerTokens is not null)
        {
            foreach (var kvp in headerTokens)
            {
                if (kvp.Value is { Count: > 0 })
                {
                    deterministicSets.Add(new DeterministicTokenSetDto(kvp.Key, kvp.Value));
                }
            }
        }

        return deterministicSets.Count > 0 ? deterministicSets : null;
    }

    private async Task ScanZeroAccessHeadersAsync()
    {
        if (!_useZeroAccess || _selectedFile is null)
        {
            ResetZeroAccessHeaderState();
            await InvokeAsync(StateHasChanged);
            return;
        }

        if (_isHeaderScanRunning)
        {
            return;
        }

        _isHeaderScanRunning = true;
        _headerIndexStatus = ZeroAccessHeaderIndexStatus.Running("Scanning message headers…");
        await InvokeAsync(StateHasChanged);

        try
        {
            var result = await JS.InvokeAsync<ZeroAccessHeaderScanResult>(
                "zeroAccessUpload.scanHeaderTokens",
                new { maxMessages = 2000, maxTokensPerType = 512 });

            if (!result.Success)
            {
                _headerPreviewValues = null;
                _headerIndexStatus = ZeroAccessHeaderIndexStatus.Skipped(DescribeHeaderScanReason(result.Reason));
                return;
            }

            var preview = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
            if (result.Values is not null)
            {
                foreach (var pair in result.Values)
                {
                    preview[pair.Key] = pair.Value ?? Array.Empty<string>();
                }
            }

            _headerPreviewValues = preview;

            var counts = preview.ToDictionary(
                pair => pair.Key,
                pair => pair.Value.Length,
                StringComparer.OrdinalIgnoreCase);

            var capped = result.Stats?.CappedTypes is not null
                ? new Dictionary<string, bool>(result.Stats.CappedTypes, StringComparer.OrdinalIgnoreCase)
                : new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);

            var scanned = result.Stats?.ScannedMessages ?? counts.Values.Sum();
            _headerIndexStatus = ZeroAccessHeaderIndexStatus.Completed(scanned, counts, capped);
        }
        catch (JSException jsEx)
        {
            _headerPreviewValues = null;
            _headerIndexStatus = ZeroAccessHeaderIndexStatus.Error($"Header indexing failed: {jsEx.Message}");
        }
        finally
        {
            _isHeaderScanRunning = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string DescribeHeaderScanReason(string? reason) => reason switch
    {
        "unsupported-format" => "Header indexing currently supports .mbox/.mbx uploads only. Tags still work as usual.",
        "no-file" => "Select a .mbox/.mbx file to build header indexes.",
        _ => "Header indexing skipped for this upload."
    };

    private void ResetZeroAccessHeaderState(string? message = null)
    {
        _headerPreviewValues = null;
        _headerHashedTokens = null;
        _isHeaderScanRunning = false;
        _headerIndexStatus = ZeroAccessHeaderIndexStatus.Hidden(message);
    }

    private Task RescanHeadersAsync() => ScanZeroAccessHeadersAsync();

    private int GetHeaderTokenCount(string tokenType) =>
        _headerIndexStatus.TokenCounts.TryGetValue(tokenType, out var count)
            ? count
            : 0;

    private bool IsHeaderTokenCapped(string tokenType) =>
        _headerIndexStatus.CappedTypes.TryGetValue(tokenType, out var capped) && capped;

    private sealed record ZeroAccessKeyBundleModel
    {
        public string KeyBase64 { get; init; } = string.Empty;
        public string Fingerprint { get; init; } = string.Empty;
        public string NoncePrefixBase64 { get; init; } = string.Empty;
        public string Scheme { get; init; } = "zero-access/aes-gcm-chunked/v1";
    };

    private sealed record ZeroAccessUploadResultModel
    {
        public string MetadataJson { get; init; } = string.Empty;
        public long CipherSizeBytes { get; init; }
    };

    private sealed record ZeroAccessHeaderIndexStatus(
        HeaderIndexState State,
        string? Message,
        int ScannedMessages,
        IReadOnlyDictionary<string, int> TokenCounts,
        IReadOnlyDictionary<string, bool> CappedTypes)
    {
        public static ZeroAccessHeaderIndexStatus Hidden(string? message = null) =>
            new(HeaderIndexState.Hidden, message, 0,
                new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase),
                new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase));

        public static ZeroAccessHeaderIndexStatus Running(string? message = null) =>
            new(HeaderIndexState.Running, message, 0,
                new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase),
                new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase));

        public static ZeroAccessHeaderIndexStatus Completed(
            int scannedMessages,
            IReadOnlyDictionary<string, int> counts,
            IReadOnlyDictionary<string, bool> cappedTypes) =>
            new(HeaderIndexState.Completed, null, scannedMessages, counts, cappedTypes);

        public static ZeroAccessHeaderIndexStatus Skipped(string? message) =>
            new(HeaderIndexState.Skipped, message, 0,
                new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase),
                new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase));

        public static ZeroAccessHeaderIndexStatus Error(string? message) =>
            new(HeaderIndexState.Error, message, 0,
                new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase),
                new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase));
    }

    private enum HeaderIndexState
    {
        Hidden,
        Running,
        Completed,
        Skipped,
        Error
    }

    private sealed class ZeroAccessHeaderScanResult
    {
        public bool Success { get; set; }
        public string? Reason { get; set; }
        public Dictionary<string, string[]>? Values { get; set; }
        public ZeroAccessHeaderScanStats? Stats { get; set; }
    }

    private sealed class ZeroAccessHeaderScanStats
    {
        public int ScannedMessages { get; set; }
        public Dictionary<string, bool>? CappedTypes { get; set; }
    }

    [JSInvokable]
    public async Task HandleUploadError(string title, string message, string? technicalDetails)
    {
        _hasClientSideError = true;

        var segments = new List<string>();
        if (!string.IsNullOrWhiteSpace(title))
        {
            segments.Add(title.Trim());
        }
        if (!string.IsNullOrWhiteSpace(message))
        {
            segments.Add(message.Trim());
        }

        var combined = segments.Count > 0 ? string.Join(": ", segments) : "Upload failed";

        if (!string.IsNullOrWhiteSpace(technicalDetails))
        {
            combined = $"{combined} ({technicalDetails})";
        }

        _errorMessage = combined;
        _isUploading = false;
        _isProcessing = false;

        await InvokeAsync(StateHasChanged);
    }
}
