@page "/upload"
@rendermode InteractiveServer
@using Evermail.Common.Constants
@using Evermail.Common.DTOs
@using Evermail.Common.DTOs.Upload
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.WebUtilities
@using Evermail.WebApp.Services
@using System.Net.Http.Json
@using System.IO
@using System.Collections.Generic
@using Microsoft.JSInterop
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject IAuthenticationStateService AuthStateService

<PageTitle>Upload Email Archive - Evermail</PageTitle>

<AuthorizeView>
    <Authorized>
<div class="home-wrapper upload-wrapper">
    <section class="page-hero upload-hero">
        <div>
            <p class="hero-eyebrow mb-2">@(_targetMailboxId.HasValue ? "Re-import" : "New ingestion")</p>
            <h1>@UploadTitle</h1>
            <p class="text-muted mb-0">@UploadSubtitle</p>
        </div>
        <div class="upload-hero-stats">
            <div>
                <span>@_maxFileSizeGB GB</span>
                <small>Per file limit</small>
            </div>
            <div>
                <span>Resume-ready</span>
                <small>Large files, pick up where you left off</small>
            </div>
            <div>
                <span>ZIP · PST · OST · EML</span>
                <small>Auto-normalized formats</small>
            </div>
        </div>
    </section>
    
    @if (_isUploading)
    {
        <section class="modern-card upload-progress-card">
            <p class="hero-eyebrow mb-1">Transferring @_fileName</p>
            <h2>Upload in progress</h2>
            <div class="usage-progress jumbo" role="progressbar" aria-valuenow="@_uploadProgress" aria-valuemin="0" aria-valuemax="100">
                <div class="progress-bar" style="width:@_uploadProgress%"></div>
            </div>
            <p class="text-muted mb-1">
                @_uploadedMB.ToString("F2") MB / @_totalMB.ToString("F2") MB · @_uploadSpeedMBps.ToString("F2") MB/s
                @if (_estimatedTimeRemaining > TimeSpan.Zero)
                {
                    <span> · ETA @_estimatedTimeRemaining.ToString(@"mm\:ss")</span>
                }
            </p>
            <button class="btn btn-outline-danger" @onclick="CancelUpload">
                <i class="bi bi-x-circle me-2"></i>Cancel upload
            </button>
        </section>
    }
    else if (_uploadComplete)
    {
        <section class="modern-card success-card text-center py-5">
            <i class="bi bi-check-circle display-5 text-success"></i>
            <h2 class="mt-3">Upload complete</h2>
            <p class="text-muted">Your archive is queued for processing. We'll notify you once ingestion finishes.</p>
            <a href="/mailboxes/@_completedMailboxId" class="btn btn-primary">
                <i class="bi bi-inbox me-2"></i>View mailbox status
            </a>
        </section>
    }
    else
    {
        @if (!string.IsNullOrEmpty(_errorMessage))
        {
            <div class="alert alert-danger modern-alert">@_errorMessage</div>
        }

        <section class="modern-card upload-card">
            <div class="upload-grid">
                <div>
                    <label class="form-label fw-semibold">Upload source</label>
                    <div class="@DropzoneCssClass"
                         @ondragenter="() => _isDragOver = true"
                         @ondragleave="() => _isDragOver = false">
                        <InputFile OnChange="HandleFileSelected"
                                   class="upload-dropzone__input"
                                   accept=".mbox,.mbx,.zip,.pst,.ost,.eml"
                                   id="fileInput"
                                   @ondragenter="() => _isDragOver = true"
                                   @ondragleave="() => _isDragOver = false"
                                   @ondragover:preventDefault="true"
                                   @ondrop="HandleDrop" />
                        <div class="upload-dropzone__content">
                            @if (_selectedFile is null)
                            {
                                <i class="bi bi-cloud-arrow-up display-5 text-muted"></i>
                                <p class="lead mb-1">Drag & drop .mbox, .pst, .ost, .eml, or .zip</p>
                                <p class="text-muted small mb-0">or click to browse files</p>
                                <span class="text-muted extra-small">Files encrypt directly to Azure Blob Storage</span>
                            }
                            else
                            {
                                <div class="upload-filechip">
                                    <div>
                                        <strong>@_fileName</strong>
                                        <span>@_totalMB.ToString("F2") MB</span>
                                    </div>
                                    <button type="button" class="upload-filechip__remove" @onclick="ClearSelection">
                                        <i class="bi bi-x-lg"></i>
                                    </button>
                                </div>
                                <p class="text-muted small mb-0">Ready to upload.</p>
                            }
                        </div>
                    </div>
                    <p class="text-muted small mt-2">Supports .mbox/.mbx, Outlook PST/OST (raw or zipped), Google Takeout, and Maildir-style `.eml` bundles — we detect the format automatically.</p>
                </div>
                <div class="upload-meta">
                    <label class="form-label fw-semibold">Format detection</label>
                    <div class="modern-card subtle-card mb-3">
                        <p class="mb-1 fw-semibold">@FormatDetectionSummary</p>
                        <p class="text-muted small mb-0">@FormatDetectionDetails</p>
                    </div>
                    <div class="upload-plan-card">
                        <p class="text-muted mb-1">Plan limit</p>
                        <h4 class="mb-0">@_maxFileSizeGB GB per file</h4>
                        <small>Need more? Upgrade under Settings → Subscription.</small>
                    </div>
                    <button class="btn btn-primary btn-xl w-100 auth-primary-button mt-2"
                            @onclick="StartUpload"
                            disabled="@(_selectedFile == null || _isProcessing)">
                        @(_targetMailboxId.HasValue ? "Merge upload" : "Start upload")
                    </button>
                </div>
            </div>
        </section>

        @if (_targetMailboxId.HasValue)
        {
            <section class="modern-card subtle-card">
                <p class="hero-eyebrow mb-1">Re-import active</p>
                <p class="mb-0">New messages merge into mailbox <span class="mono">@_targetMailboxId</span>. Duplicates are skipped automatically.</p>
            </section>
        }
    }
</div>
    </Authorized>
    <NotAuthorized>
        <CheckAuthAndRedirect />
    </NotAuthorized>
</AuthorizeView>

@code {
    private IBrowserFile? _selectedFile;
    private string _fileName = string.Empty;
    private string? _formatHint;
    private long _totalBytes;
    private double _totalMB;
    private double _totalGB;
    private int _maxFileSizeGB = 100;
    
    private bool _isUploading;
    private bool _isProcessing;
    private bool _uploadComplete;
    private int _uploadProgress;
    private long _uploadedBytes;
    private double _uploadedMB;
    private double _uploadSpeedMBps;
    private TimeSpan _estimatedTimeRemaining;
    private string _errorMessage = string.Empty;
    private Guid _completedMailboxId;
    private Guid? _targetMailboxId;
    private bool _isDragOver;
    private bool _hasClientSideError;

    private string DropzoneCssClass => _selectedFile is null
        ? _isDragOver ? "upload-dropzone upload-dropzone--drag" : "upload-dropzone"
        : "upload-dropzone upload-dropzone--selected";

    private string FormatDetectionSummary => string.IsNullOrWhiteSpace(_formatHint)
        ? "We'll auto-detect your archive"
        : $"Detected {FormatDisplayName(_formatHint)}";

    private string FormatDetectionDetails => string.IsNullOrWhiteSpace(_formatHint)
        ? "Upload ZIP, PST, OST, MBOX, or EML files — we'll inspect the contents and pick the right pipeline."
        : "Based on the current file name. We'll still verify the contents before processing.";

    private string UploadTitle => _targetMailboxId.HasValue ? "Refresh mailbox data" : "Upload email archive";
    private string UploadSubtitle => _targetMailboxId.HasValue
        ? "Merge a newer export without creating duplicates."
        : "Drag & drop .mbox, .pst, .eml, or Takeout exports to start ingestion.";

    protected override async Task OnInitializedAsync()
    {
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var query = QueryHelpers.ParseQuery(uri.Query);
        if (query.TryGetValue("mailboxId", out var mailboxIdParam) && Guid.TryParse(mailboxIdParam, out var mailboxId))
        {
            _targetMailboxId = mailboxId;
        }

        // TODO: Fetch actual tenant plan limit from API
        _maxFileSizeGB = 100;
    }

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File != null)
        {
            ApplySelectedFile(e.File);
            _isDragOver = false;
        }
    }

    private void ApplySelectedFile(IBrowserFile file)
    {
        _selectedFile = file;
        _fileName = file.Name;
        _totalBytes = file.Size;
        _totalMB = _totalBytes / (1024.0 * 1024.0);
        _totalGB = _totalBytes / (1024.0 * 1024.0 * 1024.0);
        _errorMessage = string.Empty;
        _uploadComplete = false;
        _uploadProgress = 0;
        _formatHint = GuessFormatFromExtension(Path.GetExtension(_fileName)?.ToLowerInvariant());
    }

    private void ClearSelection()
    {
        _selectedFile = null;
        _fileName = string.Empty;
        _totalBytes = 0;
        _totalMB = 0;
        _totalGB = 0;
        _isDragOver = false;
        _formatHint = null;
    }

    private void HandleDrop(DragEventArgs _)
    {
        _isDragOver = false;
        StateHasChanged();
    }

    private async Task StartUpload()
    {
        if (_selectedFile == null) return;
        
        if (_totalGB > _maxFileSizeGB)
        {
            _errorMessage = $"File size ({_totalGB:F2} GB) exceeds your plan limit ({_maxFileSizeGB} GB). Please upgrade your subscription.";
            return;
        }
        
        _isProcessing = true;
        _errorMessage = string.Empty;
        
        try
        {
            var token = await AuthStateService.GetTokenAsync();
            if (string.IsNullOrEmpty(token))
            {
                _errorMessage = "You must be logged in to upload files";
                return;
            }

            var apiUrl = $"{Navigation.BaseUri}api/v1/upload/initiate";
            var request = new HttpRequestMessage(HttpMethod.Post, apiUrl);
            request.Headers.Add("Authorization", $"Bearer {token}");
            request.Content = JsonContent.Create(new InitiateUploadRequest(
                _fileName,
                _totalBytes,
                _formatHint,
                _targetMailboxId
            ));
            
            var initiateResponse = await Http.SendAsync(request);
            
            if (!initiateResponse.IsSuccessStatusCode)
            {
                var errorContent = await initiateResponse.Content.ReadAsStringAsync();
                _errorMessage = $"Failed to initiate upload: {errorContent}";
                return;
            }

            var result = await initiateResponse.Content.ReadFromJsonAsync<ApiResponse<InitiateUploadResponse>>();
            
            if (result?.Success != true || result.Data == null)
            {
                _errorMessage = result?.Error ?? "Failed to initiate upload";
                return;
            }
            
            _isProcessing = false;
            _isUploading = true;
            
            var uploadSucceeded = await UploadToAzureBlobAsync(result.Data.UploadUrl);

            if (!uploadSucceeded)
            {
                return;
            }
            
            var completeUrl = $"{Navigation.BaseUri}api/v1/upload/complete";
            var completeRequest = new HttpRequestMessage(HttpMethod.Post, completeUrl);
            completeRequest.Headers.Add("Authorization", $"Bearer {token}");
            completeRequest.Content = JsonContent.Create(new CompleteUploadRequest(
                result.Data.MailboxId,
                result.Data.UploadId
            ));
            
            var completeResponse = await Http.SendAsync(completeRequest);
            
            if (!completeResponse.IsSuccessStatusCode)
            {
                _errorMessage = "Upload completed but failed to queue for processing";
                return;
            }
            
            _isUploading = false;
            _uploadComplete = true;
            _completedMailboxId = result.Data.MailboxId;
        }
        catch (Exception ex)
        {
            if (string.IsNullOrWhiteSpace(_errorMessage))
            {
                _errorMessage = $"Error: {ex.Message}";
            }
            _isUploading = false;
        }
        finally
        {
            _isProcessing = false;
        }
    }

    private async Task<bool> UploadToAzureBlobAsync(string sasUrl)
    {
        DotNetObjectReference<Upload>? dotNetRef = null;
        try
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("azureBlobUpload.upload", sasUrl, dotNetRef);
            return true;
        }
        catch (Exception ex)
        {
            if (!_hasClientSideError)
            {
                _errorMessage = $"Upload failed: {ex.Message}";
            }
            _isUploading = false;
            return false;
        }
        finally
        {
            dotNetRef?.Dispose();
            _hasClientSideError = false;
        }
    }

    [JSInvokable]
    public void UpdateProgress(int progress, long uploadedBytes, double speedMBps)
    {
        _uploadProgress = progress;
        _uploadedBytes = uploadedBytes;
        _uploadedMB = uploadedBytes / (1024.0 * 1024.0);
        _uploadSpeedMBps = speedMBps;
        
        if (speedMBps > 0)
        {
            var remainingBytes = _totalBytes - uploadedBytes;
            var remainingSeconds = remainingBytes / (speedMBps * 1024 * 1024);
            _estimatedTimeRemaining = TimeSpan.FromSeconds(remainingSeconds);
        }
        
        StateHasChanged();
    }

    private void CancelUpload()
    {
        _isUploading = false;
        _errorMessage = "Upload cancelled";
    }

    private string? GuessFormatFromExtension(string? extension) => extension switch
    {
        ".pst" => EmailArchiveFormats.OutlookPst,
        ".ost" => EmailArchiveFormats.OutlookOst,
        ".mbox" => EmailArchiveFormats.Mbox,
        ".mbx" => EmailArchiveFormats.Mbox,
        ".eml" => EmailArchiveFormats.Eml,
        _ => null
    };

    private static string FormatDisplayName(string format) => format switch
    {
        EmailArchiveFormats.OutlookPst => "Outlook PST",
        EmailArchiveFormats.OutlookOst => "Outlook OST",
        EmailArchiveFormats.OutlookPstZip => "Outlook PST ZIP",
        EmailArchiveFormats.OutlookOstZip => "Outlook OST ZIP",
        EmailArchiveFormats.MicrosoftExportZip => "Outlook export ZIP",
        EmailArchiveFormats.GoogleTakeoutZip => "Google Takeout ZIP",
        EmailArchiveFormats.Eml => "single EML",
        EmailArchiveFormats.EmlZip => "EML ZIP bundle",
        EmailArchiveFormats.Mbox => ".mbox archive",
        _ => format
    };

    [JSInvokable]
    public async Task HandleUploadError(string title, string message, string? technicalDetails)
    {
        _hasClientSideError = true;

        var segments = new List<string>();
        if (!string.IsNullOrWhiteSpace(title))
        {
            segments.Add(title.Trim());
        }
        if (!string.IsNullOrWhiteSpace(message))
        {
            segments.Add(message.Trim());
        }

        var combined = segments.Count > 0 ? string.Join(": ", segments) : "Upload failed";

        if (!string.IsNullOrWhiteSpace(technicalDetails))
        {
            combined = $"{combined} ({technicalDetails})";
        }

        _errorMessage = combined;
        _isUploading = false;
        _isProcessing = false;

        await InvokeAsync(StateHasChanged);
    }
}
